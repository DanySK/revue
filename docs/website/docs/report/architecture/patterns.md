---
title: Microservices patterns
position: 3
---

# Microservices patterns

## Communication patterns

Having opted for a microservice architecture, that components weakly coupled in nature, it was necessary to reason 
about **inter-process communication** modes. Depending on the situation, different are the modes of interaction. 
Specifically, if a microservice needs to communicate with another component to obtain information essential for completing 
a business operation, the **Remote Procedure Invocation** (*request/response*) pattern will be preferred. 
It will therefore be a *one-to-one* communication. 
Whereas, the **Asynchronous messaging** pattern (*publish/subscribe*, *one-way notifications*) will be preferred in situations 
where a microservice needs to communicate with other components simply to notify the occurrence of an event, a new state, 
or action taken by a user, etc.  In this case it could be either *one-to-one* or *one-to-many* communication.

In case of RPC, the communication will be implemented using the **REST** mechanism, using the *HTTP* protocol.
In case of asynchronous messaging, the communication will be based on **events**.

In both cases the messages format will be **text-based** such as *JSON*.

## External API patterns

### API Gateway

The API Gateway pattern provides a single entry point, a facade, for all clients. 
It routes requests to the appropriate microservice by encapsulating the service decomposition and APIs. Clients, 
rather than calling the services directly, call the API Gateway. When used in combination with the appropriate 
deployment platform, it provides the opportunity to load balance the requests among the microservices. 

## Deployment patterns

* **Service as a container**: each microservice is deployed as a container. In this way, the microservices are isolated 
from each other, and they can be scaled independently. Containers images are lightweight and fast to build and start
For containerization, we used **Docker**.
* **Database per service**: each microservice has its own database. Services communicate only via APIs favoring a more loosely
coupled architecture. This allows to have a database schema that is optimized for the microservice. 
* **Service discovery**: each microservice registers itself to a service registry. This allows to have a dynamic 
  environment, where the microservices can be added or removed without the need to change the configuration of the 
  other microservices.
* **Externalized configuration**: instead of hard-wiring or hard-coding a configuration for a particular environment in which the system 
would run, configuration property values are supplied at runtime. We used the **Push model** approache, where the configuration
values are passed to service using the operating system environment variables or configuration files.

## Security patterns

### Token Authentication

The system uses token-based authentication. For each request, the client must send a token in the *Authorization* header.
The token is generated by the authentication service when the user logs in. The token contains the user's information,
such as the user's id and the user's role. We use the **JWT** (JSON Web Token) standard to generate the token. 
When a request is received, the system verifies the token (which is self-contained) and can extract the user's information from it.
